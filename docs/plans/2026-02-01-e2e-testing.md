# End-to-End Testing Plan

> **For Claude:** Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create comprehensive end-to-end tests that verify the complete gesture recognition pipeline works correctly with camera input.

**Architecture:** Integration tests that exercise the full stack from camera capture through gesture matching to action execution. Uses test fixtures for reproducible results.

**Tech Stack:** Go testing, test fixtures (pre-recorded frames), mock plugins, httptest for API testing

---

## Phase 1: Test Infrastructure

### Task 1: Create Test Fixtures

**Files:**
- Create: `testdata/frames/thumbs_up_001.jpg`
- Create: `testdata/frames/thumbs_up_002.jpg`
- Create: `testdata/frames/open_palm_001.jpg`
- Create: `testdata/frames/swipe_left_sequence/` (multiple frames)
- Create: `testdata/fixtures.go`

**Step 1: Capture test frames**

Record a few frames with actual hand poses for testing. Save as JPEG files in testdata/frames/.

**Step 2: Write fixtures loader**

```go
// testdata/fixtures.go
package testdata

import (
    "embed"
    "fmt"

    "gocv.io/x/gocv"
)

//go:embed frames/*
var framesFS embed.FS

// LoadFrame loads a test frame by name
func LoadFrame(name string) (*gocv.Mat, error) {
    data, err := framesFS.ReadFile("frames/" + name)
    if err != nil {
        return nil, fmt.Errorf("load frame %s: %w", name, err)
    }

    mat, err := gocv.IMDecode(data, gocv.IMReadColor)
    if err != nil {
        return nil, fmt.Errorf("decode frame %s: %w", name, err)
    }

    return &mat, nil
}

// LoadSequence loads a sequence of frames for dynamic gesture testing
func LoadSequence(dir string) ([]*gocv.Mat, error) {
    entries, err := framesFS.ReadDir("frames/" + dir)
    if err != nil {
        return nil, err
    }

    var frames []*gocv.Mat
    for _, entry := range entries {
        if entry.IsDir() {
            continue
        }
        frame, err := LoadFrame(dir + "/" + entry.Name())
        if err != nil {
            // Clean up already loaded frames
            for _, f := range frames {
                f.Close()
            }
            return nil, err
        }
        frames = append(frames, frame)
    }

    return frames, nil
}
```

**Step 3: Commit**

```bash
git add testdata/
git commit -m "test: add test fixtures for e2e testing"
```

---

### Task 2: Create Mock Camera

**Files:**
- Create: `internal/capture/mock_camera.go`
- Create: `internal/capture/mock_camera_test.go`

**Step 1: Write mock camera**

```go
// internal/capture/mock_camera.go
package capture

import (
    "fmt"
    "sync"

    "gocv.io/x/gocv"
)

// MockCamera plays back pre-recorded frames for testing
type MockCamera struct {
    frames  []*gocv.Mat
    index   int
    loop    bool
    mu      sync.Mutex
    running bool
}

func NewMockCamera(frames []*gocv.Mat, loop bool) *MockCamera {
    return &MockCamera{
        frames: frames,
        loop:   loop,
    }
}

func (c *MockCamera) Open() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.running = true
    c.index = 0
    return nil
}

func (c *MockCamera) Close() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.running = false
    return nil
}

func (c *MockCamera) ReadFrame() (*gocv.Mat, error) {
    c.mu.Lock()
    defer c.mu.Unlock()

    if !c.running {
        return nil, fmt.Errorf("camera not open")
    }

    if len(c.frames) == 0 {
        return nil, fmt.Errorf("no frames available")
    }

    if c.index >= len(c.frames) {
        if c.loop {
            c.index = 0
        } else {
            return nil, fmt.Errorf("no more frames")
        }
    }

    // Clone the frame so the original isn't modified
    frame := c.frames[c.index].Clone()
    c.index++

    return &frame, nil
}

func (c *MockCamera) SetFPS(fps int) {}
func (c *MockCamera) FPS() int       { return 15 }
func (c *MockCamera) IsOpen() bool {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.running
}

// SetFrames replaces the frame sequence
func (c *MockCamera) SetFrames(frames []*gocv.Mat) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.frames = frames
    c.index = 0
}

// Reset restarts playback from the beginning
func (c *MockCamera) Reset() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.index = 0
}
```

**Step 2: Write tests**

```go
// internal/capture/mock_camera_test.go
package capture

import (
    "testing"

    "gocv.io/x/gocv"
)

func TestMockCamera_Playback(t *testing.T) {
    // Create test frames
    frame1 := gocv.NewMatWithSize(480, 640, gocv.MatTypeCV8UC3)
    defer frame1.Close()
    frame2 := gocv.NewMatWithSize(480, 640, gocv.MatTypeCV8UC3)
    defer frame2.Close()

    cam := NewMockCamera([]*gocv.Mat{&frame1, &frame2}, false)

    if err := cam.Open(); err != nil {
        t.Fatalf("Open() error = %v", err)
    }
    defer cam.Close()

    // Read both frames
    f1, err := cam.ReadFrame()
    if err != nil {
        t.Fatalf("ReadFrame() error = %v", err)
    }
    f1.Close()

    f2, err := cam.ReadFrame()
    if err != nil {
        t.Fatalf("ReadFrame() error = %v", err)
    }
    f2.Close()

    // Third read should fail (no loop)
    _, err = cam.ReadFrame()
    if err == nil {
        t.Error("expected error after all frames consumed")
    }
}

func TestMockCamera_Loop(t *testing.T) {
    frame := gocv.NewMatWithSize(480, 640, gocv.MatTypeCV8UC3)
    defer frame.Close()

    cam := NewMockCamera([]*gocv.Mat{&frame}, true)
    cam.Open()
    defer cam.Close()

    // Should loop indefinitely
    for i := 0; i < 5; i++ {
        f, err := cam.ReadFrame()
        if err != nil {
            t.Fatalf("ReadFrame() iteration %d error = %v", i, err)
        }
        f.Close()
    }
}
```

**Step 3: Commit**

```bash
git add internal/capture/mock_camera.go internal/capture/mock_camera_test.go
git commit -m "test: add mock camera for playback testing"
```

---

## Phase 2: Integration Tests

### Task 3: Pipeline Integration Test

**Files:**
- Create: `internal/app/app_integration_test.go`

**Step 1: Write integration test**

```go
// internal/app/app_integration_test.go
package app

import (
    "path/filepath"
    "testing"
    "time"

    "github.com/ayusman/kuchipudi/internal/capture"
    "github.com/ayusman/kuchipudi/internal/detector"
    "github.com/ayusman/kuchipudi/internal/gesture"
    "github.com/ayusman/kuchipudi/internal/store"
)

func TestApp_DetectionPipeline_StaticGesture(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    // Setup test store
    tmpDir := t.TempDir()
    dbPath := filepath.Join(tmpDir, "test.db")
    s, err := store.New(dbPath)
    if err != nil {
        t.Fatalf("store.New() error = %v", err)
    }
    defer s.Close()

    // Create test gesture
    s.Gestures().Create(&store.Gesture{
        ID:        "thumbs-up",
        Name:      "Thumbs Up",
        Type:      store.GestureTypeStatic,
        Tolerance: 0.3,
    })

    // Create app with mock detector
    app := New(Config{
        Store:        s,
        PluginDir:    tmpDir,
        CameraID:     0,
        MotionThresh: 0.05,
    })

    // Setup mock detector that returns thumbs up landmarks
    mockDetector := detector.NewMockDetector()
    mockDetector.SetHands([]detector.HandLandmarks{detector.ThumbsUpLandmarks()})
    app.SetDetector(mockDetector)

    // Add gesture template
    app.staticMatcher.AddTemplate(&gesture.Template{
        ID:        "thumbs-up",
        Name:      "Thumbs Up",
        Type:      gesture.TypeStatic,
        Landmarks: detector.ThumbsUpLandmarks().Normalize().Points[:],
        Tolerance: 0.3,
    })

    // Track matched gestures
    var matchedGestures []string
    app.OnGestureMatched(func(id, name string) {
        matchedGestures = append(matchedGestures, name)
    })

    // Start app (won't actually start camera, we'll feed frames manually)
    app.SetEnabled(true)

    // Simulate frame processing
    frame := gocv.NewMatWithSize(480, 640, gocv.MatTypeCV8UC3)
    defer frame.Close()

    hands, _ := app.detector.Detect(&frame)
    matches := app.staticMatcher.Match(&hands[0])

    if len(matches) == 0 {
        t.Fatal("expected thumbs up gesture to match")
    }

    if matches[0].Template.Name != "Thumbs Up" {
        t.Errorf("wrong gesture matched: %s", matches[0].Template.Name)
    }
}

func TestApp_DetectionPipeline_DynamicGesture(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    // Setup
    tmpDir := t.TempDir()
    dbPath := filepath.Join(tmpDir, "test.db")
    s, _ := store.New(dbPath)
    defer s.Close()

    app := New(Config{
        Store:        s,
        PluginDir:    tmpDir,
        MotionThresh: 0.05,
    })

    // Add swipe left template
    app.dynamicMatcher.AddTemplate(&gesture.Template{
        ID:   "swipe-left",
        Name: "Swipe Left",
        Type: gesture.TypeDynamic,
        Path: []gesture.PathPoint{
            {X: 0.8, Y: 0.5, Timestamp: 0},
            {X: 0.5, Y: 0.5, Timestamp: 100},
            {X: 0.2, Y: 0.5, Timestamp: 200},
        },
        Tolerance: 0.5,
    })

    // Simulate swipe left path
    inputPath := []gesture.PathPoint{
        {X: 0.9, Y: 0.5, Timestamp: 0},
        {X: 0.6, Y: 0.5, Timestamp: 100},
        {X: 0.3, Y: 0.5, Timestamp: 200},
    }

    matches := app.dynamicMatcher.Match(inputPath)

    if len(matches) == 0 {
        t.Fatal("expected swipe left to match")
    }

    if matches[0].Template.Name != "Swipe Left" {
        t.Errorf("wrong gesture matched: %s", matches[0].Template.Name)
    }
}

func TestApp_IdleActiveMode_Switching(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    tmpDir := t.TempDir()
    s, _ := store.New(filepath.Join(tmpDir, "test.db"))
    defer s.Close()

    app := New(Config{
        Store:        s,
        PluginDir:    tmpDir,
        MotionThresh: 0.05,
    })

    // Initially should be in idle mode
    // (internal state tracking would need to be exposed for this test)

    // This test verifies the mode switching logic works correctly
    // In a real test, we'd use the mock camera and motion detector
}
```

**Step 2: Commit**

```bash
git add internal/app/app_integration_test.go
git commit -m "test: add pipeline integration tests"
```

---

### Task 4: API Integration Test

**Files:**
- Create: `internal/server/server_integration_test.go`

**Step 1: Write API integration tests**

```go
// internal/server/server_integration_test.go
package server

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "path/filepath"
    "testing"

    "github.com/ayusman/kuchipudi/internal/store"
)

func TestAPI_GestureWorkflow(t *testing.T) {
    // Setup
    tmpDir := t.TempDir()
    s, _ := store.New(filepath.Join(tmpDir, "test.db"))
    defer s.Close()

    srv := New(Config{Store: s})
    ts := httptest.NewServer(srv)
    defer ts.Close()

    client := ts.Client()

    // 1. Create a gesture
    createBody := `{"name": "test-gesture", "type": "static"}`
    resp, err := client.Post(ts.URL+"/api/gestures", "application/json", bytes.NewBufferString(createBody))
    if err != nil {
        t.Fatalf("POST /api/gestures error = %v", err)
    }
    if resp.StatusCode != http.StatusCreated {
        t.Fatalf("POST status = %d, want %d", resp.StatusCode, http.StatusCreated)
    }

    var created struct {
        ID   string `json:"id"`
        Name string `json:"name"`
    }
    json.NewDecoder(resp.Body).Decode(&created)
    resp.Body.Close()

    if created.Name != "test-gesture" {
        t.Errorf("created name = %s, want test-gesture", created.Name)
    }

    // 2. List gestures
    resp, _ = client.Get(ts.URL + "/api/gestures")
    if resp.StatusCode != http.StatusOK {
        t.Fatalf("GET /api/gestures status = %d, want %d", resp.StatusCode, http.StatusOK)
    }

    var listed struct {
        Gestures []struct {
            ID   string `json:"id"`
            Name string `json:"name"`
        } `json:"gestures"`
    }
    json.NewDecoder(resp.Body).Decode(&listed)
    resp.Body.Close()

    if len(listed.Gestures) != 1 {
        t.Fatalf("len(gestures) = %d, want 1", len(listed.Gestures))
    }

    // 3. Get single gesture
    resp, _ = client.Get(ts.URL + "/api/gestures/" + created.ID)
    if resp.StatusCode != http.StatusOK {
        t.Fatalf("GET /api/gestures/%s status = %d, want %d", created.ID, resp.StatusCode, http.StatusOK)
    }
    resp.Body.Close()

    // 4. Delete gesture
    req, _ := http.NewRequest(http.MethodDelete, ts.URL+"/api/gestures/"+created.ID, nil)
    resp, _ = client.Do(req)
    if resp.StatusCode != http.StatusNoContent {
        t.Fatalf("DELETE status = %d, want %d", resp.StatusCode, http.StatusNoContent)
    }
    resp.Body.Close()

    // 5. Verify deleted
    resp, _ = client.Get(ts.URL + "/api/gestures/" + created.ID)
    if resp.StatusCode != http.StatusNotFound {
        t.Fatalf("GET after delete status = %d, want %d", resp.StatusCode, http.StatusNotFound)
    }
    resp.Body.Close()
}

func TestAPI_HealthCheck(t *testing.T) {
    srv := New(Config{})
    ts := httptest.NewServer(srv)
    defer ts.Close()

    resp, err := ts.Client().Get(ts.URL + "/api/health")
    if err != nil {
        t.Fatalf("GET /api/health error = %v", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        t.Fatalf("status = %d, want %d", resp.StatusCode, http.StatusOK)
    }

    var health struct {
        Status string `json:"status"`
        Uptime string `json:"uptime"`
    }
    json.NewDecoder(resp.Body).Decode(&health)

    if health.Status != "ok" {
        t.Errorf("status = %s, want ok", health.Status)
    }
}
```

**Step 2: Commit**

```bash
git add internal/server/server_integration_test.go
git commit -m "test: add API integration tests"
```

---

### Task 5: Plugin Integration Test

**Files:**
- Create: `internal/plugin/plugin_integration_test.go`

**Step 1: Write plugin integration test**

```go
// internal/plugin/plugin_integration_test.go
package plugin

import (
    "encoding/json"
    "os"
    "path/filepath"
    "runtime"
    "testing"
)

func TestPlugin_SystemControl_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    if runtime.GOOS != "darwin" {
        t.Skip("system-control plugin only works on macOS")
    }

    // Find the built plugin
    pluginDir := findPluginDir("system-control")
    if pluginDir == "" {
        t.Skip("system-control plugin not built")
    }

    mgr := NewManager(filepath.Dir(pluginDir))
    if err := mgr.Discover(); err != nil {
        t.Fatalf("Discover() error = %v", err)
    }

    plugin, err := mgr.Get("system-control")
    if err != nil {
        t.Fatalf("Get() error = %v", err)
    }

    executor := NewExecutor(5000)

    // Test with an action that doesn't have side effects
    // (volume-mute toggles, so we'd need to restore state)
    // Instead, test with an invalid action to verify error handling
    req := &Request{
        Action: "execute",
        Params: json.RawMessage(`{"action_name": "invalid-action"}`),
    }

    resp, err := executor.Execute(plugin, req)
    if err != nil {
        t.Fatalf("Execute() error = %v", err)
    }

    if resp.Success {
        t.Error("expected failure for invalid action")
    }
}

func TestPlugin_Keyboard_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    if runtime.GOOS != "darwin" {
        t.Skip("keyboard plugin only works on macOS")
    }

    pluginDir := findPluginDir("keyboard")
    if pluginDir == "" {
        t.Skip("keyboard plugin not built")
    }

    mgr := NewManager(filepath.Dir(pluginDir))
    mgr.Discover()

    plugin, err := mgr.Get("keyboard")
    if err != nil {
        t.Fatalf("Get() error = %v", err)
    }

    executor := NewExecutor(5000)

    // Test with missing key parameter
    req := &Request{
        Action: "execute",
        Params: json.RawMessage(`{"key": ""}`),
    }

    resp, err := executor.Execute(plugin, req)
    if err != nil {
        t.Fatalf("Execute() error = %v", err)
    }

    if resp.Success {
        t.Error("expected failure for empty key")
    }
}

func findPluginDir(name string) string {
    candidates := []string{
        filepath.Join("../../plugins", name),
        filepath.Join("../../../plugins", name),
    }

    for _, dir := range candidates {
        manifest := filepath.Join(dir, "plugin.json")
        if _, err := os.Stat(manifest); err == nil {
            return dir
        }
    }
    return ""
}
```

**Step 2: Commit**

```bash
git add internal/plugin/plugin_integration_test.go
git commit -m "test: add plugin integration tests"
```

---

## Phase 3: End-to-End Tests

### Task 6: Full E2E Test

**Files:**
- Create: `e2e/e2e_test.go`

**Step 1: Write E2E test**

```go
// e2e/e2e_test.go
package e2e

import (
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "os"
    "path/filepath"
    "testing"
    "time"

    "github.com/ayusman/kuchipudi/internal/app"
    "github.com/ayusman/kuchipudi/internal/detector"
    "github.com/ayusman/kuchipudi/internal/gesture"
    "github.com/ayusman/kuchipudi/internal/server"
    "github.com/ayusman/kuchipudi/internal/store"
)

func TestE2E_CompleteWorkflow(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping e2e test")
    }

    // Setup data directory
    tmpDir := t.TempDir()
    dbPath := filepath.Join(tmpDir, "data.db")

    // Initialize store
    s, err := store.New(dbPath)
    if err != nil {
        t.Fatalf("store.New() error = %v", err)
    }
    defer s.Close()

    // Create server
    srv := server.New(server.Config{
        Store: s,
    })
    ts := httptest.NewServer(srv)
    defer ts.Close()

    client := ts.Client()

    // === Step 1: Create a gesture via API ===
    t.Run("CreateGesture", func(t *testing.T) {
        resp, err := client.Post(
            ts.URL+"/api/gestures",
            "application/json",
            strings.NewReader(`{"name": "wave", "type": "dynamic"}`),
        )
        if err != nil {
            t.Fatalf("create gesture error = %v", err)
        }
        defer resp.Body.Close()

        if resp.StatusCode != http.StatusCreated {
            t.Fatalf("status = %d, want %d", resp.StatusCode, http.StatusCreated)
        }
    })

    // === Step 2: Initialize app ===
    application := app.New(app.Config{
        Store:        s,
        PluginDir:    filepath.Join(tmpDir, "plugins"),
        MotionThresh: 0.05,
    })

    // Use mock detector
    mockDetector := detector.NewMockDetector()
    application.SetDetector(mockDetector)

    // === Step 3: Load gestures from database ===
    t.Run("LoadGestures", func(t *testing.T) {
        if err := application.LoadGestures(); err != nil {
            t.Fatalf("LoadGestures() error = %v", err)
        }
    })

    // === Step 4: Simulate gesture detection ===
    t.Run("DetectGesture", func(t *testing.T) {
        // Setup mock to return a hand
        mockDetector.SetHands([]detector.HandLandmarks{detector.ThumbsUpLandmarks()})

        // Add a matching template
        application.StaticMatcher().AddTemplate(&gesture.Template{
            ID:        "test-thumbs-up",
            Name:      "Test Thumbs Up",
            Type:      gesture.TypeStatic,
            Landmarks: detector.ThumbsUpLandmarks().Normalize().Points[:],
            Tolerance: 0.3,
        })

        // Simulate detection
        hands, _ := mockDetector.Detect(nil)
        matches := application.StaticMatcher().Match(&hands[0])

        if len(matches) == 0 {
            t.Error("expected gesture to match")
        }
    })

    // === Step 5: Verify API still works after app operations ===
    t.Run("APIStillWorks", func(t *testing.T) {
        resp, _ := client.Get(ts.URL + "/api/health")
        if resp.StatusCode != http.StatusOK {
            t.Errorf("health check failed after app operations")
        }
        resp.Body.Close()
    })
}

func TestE2E_GestureRecordAndMatch(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping e2e test")
    }

    tmpDir := t.TempDir()
    s, _ := store.New(filepath.Join(tmpDir, "data.db"))
    defer s.Close()

    // Simulate recording workflow
    // 1. Create gesture
    g := &store.Gesture{
        ID:        "recorded-1",
        Name:      "Custom Gesture",
        Type:      store.GestureTypeStatic,
        Tolerance: 0.25,
    }
    s.Gestures().Create(g)

    // 2. "Record" samples (in reality, from UI)
    landmarks := detector.ThumbsUpLandmarks()

    // 3. Build template from recorded samples
    template := &gesture.Template{
        ID:        g.ID,
        Name:      g.Name,
        Type:      gesture.TypeStatic,
        Landmarks: landmarks.Normalize().Points[:],
        Tolerance: g.Tolerance,
    }

    // 4. Add to matcher
    matcher := gesture.NewStaticMatcher()
    matcher.AddTemplate(template)

    // 5. Test matching
    input := detector.ThumbsUpLandmarks()
    matches := matcher.Match(&input)

    if len(matches) == 0 {
        t.Error("recorded gesture should match input")
    }

    if matches[0].Score < 0.9 {
        t.Errorf("score = %f, expected > 0.9 for identical gesture", matches[0].Score)
    }
}
```

**Step 2: Add required import**

```go
import "strings"
```

**Step 3: Commit**

```bash
git add e2e/
git commit -m "test: add end-to-end tests for complete workflow"
```

---

## Summary

| Task | Description |
|------|-------------|
| 1 | Create test fixtures (pre-recorded frames) |
| 2 | Create mock camera for playback testing |
| 3 | Add pipeline integration tests |
| 4 | Add API integration tests |
| 5 | Add plugin integration tests |
| 6 | Create full end-to-end workflow tests |

**Running Tests:**

```bash
# Unit tests only (fast)
make test-short

# All tests including integration
make test

# E2E tests only
go test ./e2e/... -v

# With coverage
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

**Test Categories:**

| Type | Location | What it tests |
|------|----------|---------------|
| Unit | `*_test.go` in each package | Individual functions |
| Integration | `*_integration_test.go` | Component interactions |
| E2E | `e2e/` | Complete user workflows |

**CI/CD Integration:**

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - run: brew install opencv
      - run: make test
```
